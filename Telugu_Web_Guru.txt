Data types
``````````

Primitive
`````````

		  integer 	:	byte ,short ,int,long

		  float		:	float

		  boolean 	:	boolean

		  double 	:	double

		  character	:	char

Non-primitive
`````````````
class ,interface ,array ,enum

===========================================================================================================================================================
Operators:
`````````

1\. Arithmetic Operators



2\. Unary Operators: Operate on a single operand

	+ (Unary plus - indicates positive value)

	- (Unary minus - negates a value)

	++ (Increment - increases value by 1)

	-- (Decrement - decreases value by 1)

	! (Logical NOT - inverts a boolean value)



3\. Assignment Operators: Assign values to variables.

	= (Simple assignment)

	+= (Add and assign)

	-= (Subtract and assign)

	*= (Multiply and assign)

	/= (Divide and assign)

	%= (Modulus and assign)



4\. Relational (Comparison) Operators: Compare two operands and return a boolean result.

	== (Equal to)

	!= (Not equal to)

	> (Greater than)

	< (Less than)

	>= (Greater than or equal to)

	<= (Less than or equal to)



5\. Logical Operators: Combine boolean expressions.

	&& (Logical AND - true if both operands are true)

	|| (Logical OR - true if at least one operand is true) 



6\. Bitwise Operators: Perform operations on individual bits of integer types.

	& (Bitwise AND)

	|| (Bitwise OR)

	^ (Bitwise XOR)

	~ (Bitwise Complement)

	<< (Signed Left Shift)

	>> (Signed Right Shift)

	>>> (Unsigned Right Shift)

7\. Ternary (Conditional) Operator: A shorthand for an if-then-else statement.

	condition ? expression1 : expression2

8\. Type Comparison Operator:

	instanceof: Checks if an object is an instance of a particular class or interface.

============================================================================================================================================================

Control statements:

``````````````````
for();
while();
do while();


while loop
``````````

class Whileloop {   

   public static void main(String[] args) {

      int i=0;

        while (i<6)

        {

            System.out.println("Hello");

            i++;
	}
   }
}



---------------------------------------------------------------------

For loop
````````
for(int i=1;i<=10;i++){

            System.out.print(i+" ");
	}
Another way of for loop
```````````````````````
int i;
for(i=1; ; )
{
if(i<10)
	{
	  System.out.println(i);
	  i\*=2;	
	}

	else
	break;
}
System.out.println(i);
============================================================================================================================================================

I/O operations :

InputStreamReader i = new InuttStreamReader(System.in);
BuferedReader b = new BufferedReader(i);

String name = b.readLine();

=>  or we can use Scanner  class also .

Scanner s = new Scanner (System.in);



Example program:

import java.util.Scanner;

public class PrimitiveInputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Taking input for each primitive type

        System.out.print("Enter a byte value: ");
        byte byteValue = scanner.nextByte();					

        System.out.print("Enter a short value: ");
        short shortValue = scanner.nextShort();

        System.out.print("Enter an int value: ");
        int intValue = scanner.nextInt();

        System.out.print("Enter a long value: ");
        long longValue = scanner.nextLong();

        System.out.print("Enter a float value: ");
        float floatValue = scanner.nextFloat();

        System.out.print("Enter a double value: ");
        double doubleValue = scanner.nextDouble();

        System.out.print("Enter a boolean value (true/false): ");
        boolean booleanValue = scanner.nextBoolean();

        System.out.print("Enter a character: ");
        char charValue = scanner.next().charAt(0); // Read string and take first character

        // Displaying the values
        System.out.println("\nYou entered:");
        System.out.println("Byte: " + byteValue);
        System.out.println("Short: " + shortValue);
        System.out.println("Int: " + intValue);
        System.out.println("Long: " + longValue);
        System.out.println("Float: " + floatValue);
        System.out.println("Double: " + doubleValue);
        System.out.println("Boolean: " + booleanValue);
        System.out.println("Char: " + charValue);

        scanner.close();
    }
}
============================================================================================================================================================
Arrays in java :
```````````````
OneDimensional array:

// Declaration
dataType[] arrayName;

// Declaration + Memory Allocation
dataType[] arrayName = new dataType[size];

// Declaration + Initialization
dataType[] arrayName = {value1, value2, value3, ..., valueN};


1) Indexing  		: 	Array indices start from 0. So, the first element is at index 0, second at 1, and so on.
2) Fixed Size 		:	Once declared, the size of an array cannot be changed.
3) Homogeneous Elements : 	All elements must be of the same data type.
4) Accessing Elements   : 	Use arrayName[index] to access or modify elements.
5) Length 		: 	Use arrayName.length to get the number of elements.

Common points to remember :
- Traversal: Loop through each element
- Search: Linear search or binary search (if sorted)
- Sort: Use Arrays.sort(array)
- Copy: Use Arrays.copyOf() or manual loop
- Reverse: Swap elements from both ends

Example Program :

public class ArrayExample {
    public static void main(String[] args) {
        int[] scores = new int[5];

        // Assign values
        scores[0] = 70;
        scores[1] = 85;
        scores[2] = 90;
        scores[3] = 75;
        scores[4] = 88;

        // Print values
        for (int i = 0; i < scores.length; i++) {
            System.out.println("Score " + (i+1) + ": " + scores[i]);
        }
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
2D Array:

A 2D array in Java is an array of arrays, allowing you to store data in a grid-like structure with rows and columns. It's ideal for representing matrices, tables, or board games.

ðŸ› ï¸ Declaration and Initialization

// Declaration
int[][] arr;

// Initialization
arr = new int[3][4]; // 3 rows, 4 columns

// Declaration + Initialization
int[][] grid = {
    {10, 20},
    {30, 40},
    {50, 60}
};



ðŸ“¦ Accessing and Modifying Elements
System.out.println(grid[1][1]); // Output: 40

grid[2][0] = 55; // Update value at row 2, column 0



ðŸ” Iterating Through a 2D Array

for (int i = 0; i < grid.length; i++) {
    for (int j = 0; j < grid[i].length; j++) {
        System.out.print(grid[i][j] + " ");
    }
    System.out.println();
}



âœ… Example Program

public class TwoDArrayExample {
    public static void main(String[] args) {
        int[][] marks = new int[2][3];

        // Assign values
        marks[0][0] = 85;
        marks[0][1] = 90;
        marks[0][2] = 78;
        marks[1][0] = 88;
        marks[1][1] = 92;
        marks[1][2] = 81;

        // Print values
        for (int i = 0; i < marks.length; i++) {
            for (int j = 0; j < marks[i].length; j++) {
                System.out.print(marks[i][j] + " ");
            }
            System.out.println();
        }
    }
}



ðŸ§© Key Concepts
Declaration  int[[]arr;
Initialization arr=new int[rows][cols];
Access arr[i][j];
Update arr[i][j] = value;
length   arr.length for rows ,arr[i].length for colums
Iteration   we use nested for loop.

ðŸ§  Use Cases
- Matrices and mathematical operations
- Game boards (like chess or tic-tac-toe)
- Tabular data (student marks, sales reports)
- Image processing (pixel grids)


===================================================================================================================================================================

String ,StringBuilder & String buffer: 

In Java, String, StringBuilder, and StringBuffer are classes used to handle text, but they differ in mutability, performance, and thread safety.

1. String â€“ Immutable Text
- Immutable: Once created, a String cannot be changed.
- Stored in String Pool: Helps with memory efficiency.
- Best for: Fixed or rarely modified text.
âœ… Example:
String str = "Hello";
str.concat(" World");
System.out.println(str); // Output: Hello

str.concat(" World") creates a new string but doesn't change str.

ðŸ§± 2. StringBuilder â€“ Mutable & Fast
- Mutable: Can change content without creating new objects.
- Not thread-safe: Faster in single-threaded environments.
- Best for: Frequent string modifications (e.g., loops, appends).
âœ… Example:
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb); // Output: Hello World


ðŸ”§ Common Methods:
- append()
- insert()
- delete()
- reverse()
- toString()


ðŸ§µ 3. StringBuffer â€“ Mutable & Thread-Safe
- Mutable: Like StringBuilder.
- Thread-safe: Synchronized methods.
- Best for: Multi-threaded applications needing safe string operations.
âœ… Example:
StringBuffer sbf = new StringBuffer("Hello");
sbf.append(" World");
System.out.println(sbf); // Output: Hello World



ðŸ§  When to Use What?
- Use String when the text doesnâ€™t change.
- Use StringBuilder for fast, single-threaded edits.
- Use StringBuffer for thread-safe operations.


OOPS Features:

Class 
Object 
Abstraction
Encapsulation
Polymorphism
Inheritance

ðŸ§© 1. Abstraction
âœ… Definition:

Abstraction is the process of hiding implementation details and showing only the essential features of an object.
It helps to reduce complexity and increase reusability.

Achieved using abstract classes or interfaces.

ðŸ’» Example:
// Abstract class example
abstract class Vehicle {
    abstract void start(); // abstract method (no body)
}

class Car extends Vehicle {
    void start() {
        System.out.println("Car starts with a key");
    }
}

class Bike extends Vehicle {
    void start() {
        System.out.println("Bike starts with a kick");
    }
}

public class AbstractionExample {
    public static void main(String[] args) {
        Vehicle v1 = new Car();
        Vehicle v2 = new Bike();

        v1.start();
        v2.start();
    }
}

ðŸ§  Output:
Car starts with a key
Bike starts with a kick

=============================================================================================
ðŸ§³ 2. Encapsulation
âœ… Definition:

Encapsulation means wrapping data (variables) and code (methods) together as a single unit.
It helps to protect data from unauthorized access by using private fields and public getters/setters.

ðŸ’» Example:
class Student {
    private String name; // private data
    private int age;

    // Public getter and setter methods
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }

    public void setAge(int age) {
        if (age > 0) {
            this.age = age;
        }
    }
    public int getAge() {
        return age;
    }
}

public class EncapsulationExample {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("John");
        s.setAge(20);

        System.out.println("Name: " + s.getName());
        System.out.println("Age: " + s.getAge());
    }
}

ðŸ§  Output:
Name: John
Age: 20

=============================================================================================
ðŸŽ­ 3. Polymorphism
âœ… Definition:

Polymorphism means â€œmany formsâ€ â€” it allows one action to behave differently based on the object.

Achieved through:

Compile-time polymorphism â†’ Method Overloading
Runtime polymorphism â†’ Method Overriding


ðŸ’» (a) Compile-time Polymorphism - Method Overloading
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class OverloadingExample {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.add(10, 20));       // calls 2-parameter method
        System.out.println(c.add(10, 20, 30));   // calls 3-parameter method
    }
}

ðŸ§  Output:
30
60

ðŸ’» (b) Runtime Polymorphism - Method Overriding
In this case when we instanciate child class & try calling method ,it will call only methods which are local to child class ,if we want to call super class method then we should use super keyword if parent class is not instanciated.
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class OverridingExample {
    public static void main(String[] args) {
        Animal a = new Animal(); 
        a.sound(); // runtime polymorphism
		Dog d = new Dog();
		d.sound();
    }
}

ðŸ§  Output:
Dog barks
=============================================================================================

ðŸ§¬ 4. Inheritance
âœ… Definition:

Inheritance allows a class (child/subclass) to inherit properties and methods from another class (parent/superclass).
It promotes code reusability and hierarchical classification.

ðŸ’» Example:
class Person {
    String name = "John";

    void showName() {
        System.out.println("Name: " + name);
    }
}

class Employee extends Person {
    String company = "Google";

    void showCompany() {
        System.out.println("Company: " + company);
    }
}

public class InheritanceExample {
    public static void main(String[] args) {
        Employee e = new Employee();
        e.showName();      // inherited method
        e.showCompany();   // own method
    }
}

ðŸ§  Output:
Name: John
Company: Google


=====================================================================================================================================================================
METHODS IN JAVA:
```````````````
A Method represents group of statements that performs a task.

Based on Static Keyword :
````````````````````````
Static methods
Instance methods

Based on parameters:
````````````````````
Parameterised methods
non-Parameterises methods

Based on return type:
````````````````````
With return type
Without return type


Difference between function and method ?
	Functions that are defined inside a class are said to be methods.
How to create a method ?
A method can be declared as follows:

static/non static returntype methodname (optional parameters)
{
	// method code
}


We can invoke/call the method of a class by using object.

objectname.method(optional parameters)

Here the parameters must be matched with the method definition in number of parameters and their data types.
following example defines printarray method in class ArEx and it is invoked from main class by creating object .

Example program to demonstrate addition of two numbers using methods concept:
class MethodAt
    {
         public static void main(String ar[])
         {
             Sum ob = new Sum();	//obj creation
             ob.add(2,3);	//method call
         }
    }
class Sum
    {
        void add(int a,int b){
            int addition = a+b;
            System.out.println("Sum of "+a+" & "+b+" is "+addition);
        } 
    }
========================================================================================================================================================================
CONSTRUCTORS IN JAVA:
````````````````````
Constructors in Java are special methods used to initialize objects when they are created. They have the same name as the class and no return type.

ðŸ§± What is a Constructor?
A constructor is a block of code that:
- Has the same name as the class
- Does not have a return type (not even void)
- Is automatically called when an object is created using new
- Is used to initialize object properties

ðŸ“Œ Key Rules of Constructors
- Must have the same name as the class.
- Cannot be abstract, static, final, or synchronized.
- Can be overloaded (multiple constructors with different parameters).
- Can call another constructor using this() or super().


âœ… Example 1: Default Constructor:

class Car {
    Car() {
        System.out.println("Default constructor called");
    }

    public static void main(String[] args) {
        Car myCar = new Car(); // Constructor is called here
    }
}

Output:
Default constructor called

âœ… Example 2: Parameterized Constructor
class Car {
    String model;

    Car(String m) {
        model = m;
    }

    public static void main(String[] args) {
        Car myCar = new Car("Honda City");
        System.out.println("Model: " + myCar.model);
    }
}
Output:
Model: Honda City


âœ… Example 3: Constructor Overloading


class Car {
    String model;
    int year;

    Car() {
        model = "Unknown";
        year = 0;
    }

    Car(String m, int y) {
        model = m;
        year = y;
    }

    public void display() {
        System.out.println("Model: " + model + ", Year: " + year);
    }

    public static void main(String[] args) {
        Car car1 = new Car();
        Car car2 = new Car("Hyundai i20", 2022);
        car1.display();
        car2.display();
    }
}
Output:
Model: Unknown, Year: 0
Model: Hyundai i20, Year: 2022

ðŸ” Example 4: Copy Constructor

class Car {
    String model;

    Car(String m) {
        model = m;
    }

    // Copy constructor
    Car(Car c) {
        model = c.model;
    }

    public void display() {
        System.out.println("Model: " + model);
    }

    public static void main(String[] args) {
        Car car1 = new Car("Tata Nexon");
        Car car2 = new Car(car1); // Copy constructor
        car2.display();
    }
}
Output :

Model: Tata Nexon


Super Keyword:
`````````````
1)To access super class members 
2)To call super class constructors

We use this super keyword only in subclass but can't use in class containing main method.

When we have members in both super class and subclass with same name ,to access superclass members in sub-class we use super keyword.Because by default sub-class prioritizes it's own (local)members when we try calling using sub-class obj.

to call a variable&methods we use 
super.variable_name;
super.method_name();

to call a constructor we use 
super(parameters list);

//program to demonstrate super keyword uses
class SuperEx
    {
         public static void main(String ar[])
            {
                B obj = new B();
                obj.show();
            }
    }
class A
{
     int p = 10; //member variables
    
     void show() //member methods
     {
        System.out.println("class A:"+p);
     }

}
class B extends A
{
    //p=10,show() --> from class A
    int q = 20;
    int p = 45;
    
    void show(){
    
     super.show();
    
     System.out.println("Class B:"+super.p);
     System.out.println("Class B:"+p);
     System.out.println("Class B:"+q);
    
     }

}

========================================================================================================

Abstract Class:
``````````````

A class is said to be an abstract class in which itâ€™s having at least one abstract method.
A method that is just declared without definition is said to be an abstract method.
Abstract methods can have both abstract methods and concrete methods.

abstract class ex
{
	void display() // concrete method
		{
			System.out.println("hello");
		}
	abstract void show(); //abstract method
}

In above example display method is declared with definition (method code). That's why this is called as concrete method.
where as show method is called as abstract method because there is no method definition (code) provided with its declaration. All these abstract methods must be implemented in subclasses as it is not done here.
Because class ex contains at least one abstract method show() , class ex became abstract class.
Note: As some of the methods in abstract classes are not having method definition, we cannot create objects for abstract classes.


//program to demonstrate abstract classes in java
abstract class CGovt
{
    void otherdirections()//concrete methods
        {
            System.out.println("I am from otherdirections method");
        }
    abstract void actionsTobeTaken(); //abstract method
    abstract void actionsTobeTaken1(); //abstract method
}
class AP extends CGovt
{
    void actionsTobeTaken1()
        {
         System.out.println("I am from actionsTobeTaken1 in AP");
        }
    void actionsTobeTaken()
        {
         System.out.println("I am from actionsTobeTaken in AP");
        }
}
class TG extends CGovt
{
    void actionsTobeTaken1()
        {
         System.out.println("I am from actionsTobeTaken1 in TG");
        }
    void actionsTobeTaken()
        {
         System.out.println("I am from actionsTobeTaken in TG");
        }
}
class AbsClass
{
    public static void main(String ar[])
    {
        //CGovt cg = new CGovt();
        AP ap = new AP();
        ap.actionsTobeTaken();
        ap.otherdirections();
        TG tg = new TG();
        tg.otherdirections();
        tg.actionsTobeTaken();
    }
}


Output:
```````
I am from actionsTobeTaken in AP
I am from otherdirections method
I am from otherdirections method
I am from actionsTobeTaken in TG


========================================================================================================================================================================
INTERFACES IN JAVA
``````````````````
An Interface is similar to a class which contains collection of variables and methods where all the methods in interface are by default abstract methods and all variables in methods are static and final variables.
We no need to specify any method or interface with abstract keyword because by default these are abstract. All the methods in interface are implemented in sub classes of this interface.
As no methods are having definition we cannot create objects for interfaces.

//program to demonstrate the interface concept
interface A {
    int p= 10;
    void display();
    void show();
}
class B implements A{
    public void display(){
        System.out.println("Display method in B ,p value in interface :"+A.p);
    }
    public void show(){
       System.out.println("Show method in B ,p value in interface :"+A.p);
    }
}
class main{
    public static void main(String[] args){
        B ob = new B();
        ob.show();
        ob.display();
    }
}

Output:
Show method in B ,p value in interface :10
Display method in B ,p value in interface :10

***Multiple inheritance using interface can be acheived .
While implementing multiple inheritance with interfaces, we should remember that while declaring super classes all the entities must be interfaces or at most one class is allowed.

Example :

class A{
    void methodA(){
        System.out.println("This is methodA from class A");
    }
}
interface B{
    void methodB();
}
interface C{
    void methodC();
}
class D extends A implements B,C{
    public void methodB(){
        System.out.println("This is methodB from B interface B");
    }  
    public void methodC(){
        System.out.println("This is methodC from interface C");
    }
}
class Main{
    public static void main(String[] args){
        D ob = new D();
        ob.methodA();
        ob.methodB();
        ob.methodC();
    }
}

Output:
``````
This is methodA from class A
This is methodB from B interface B
This is methodC from interface C
