Data types
``````````

Primitive
`````````

		  integer 	:	byte ,short ,int,long

		  float		:	float

		  boolean 	:	boolean

		  double 	:	double

		  character	:	char

Non-primitive
`````````````
class ,interface ,array ,enum

===========================================================================================================================================================
Operators:
`````````

1\. Arithmetic Operators



2\. Unary Operators: Operate on a single operand

	+ (Unary plus - indicates positive value)

	- (Unary minus - negates a value)

	++ (Increment - increases value by 1)

	-- (Decrement - decreases value by 1)

	! (Logical NOT - inverts a boolean value)



3\. Assignment Operators: Assign values to variables.

	= (Simple assignment)

	+= (Add and assign)

	-= (Subtract and assign)

	*= (Multiply and assign)

	/= (Divide and assign)

	%= (Modulus and assign)



4\. Relational (Comparison) Operators: Compare two operands and return a boolean result.

	== (Equal to)

	!= (Not equal to)

	> (Greater than)

	< (Less than)

	>= (Greater than or equal to)

	<= (Less than or equal to)



5\. Logical Operators: Combine boolean expressions.

	&& (Logical AND - true if both operands are true)

	|| (Logical OR - true if at least one operand is true) 



6\. Bitwise Operators: Perform operations on individual bits of integer types.

	& (Bitwise AND)

	|| (Bitwise OR)

	^ (Bitwise XOR)

	~ (Bitwise Complement)

	<< (Signed Left Shift)

	>> (Signed Right Shift)

	>>> (Unsigned Right Shift)

7\. Ternary (Conditional) Operator: A shorthand for an if-then-else statement.

	condition ? expression1 : expression2

8\. Type Comparison Operator:

	instanceof: Checks if an object is an instance of a particular class or interface.

============================================================================================================================================================

Control statements:

``````````````````
for();
while();
do while();


while loop
``````````

class Whileloop {   

   public static void main(String[] args) {

      int i=0;

        while (i<6)

        {

            System.out.println("Hello");

            i++;
	}
   }
}



---------------------------------------------------------------------

For loop
````````
for(int i=1;i<=10;i++){

            System.out.print(i+" ");
	}
Another way of for loop
```````````````````````
int i;
for(i=1; ; )
{
if(i<10)
	{
	  System.out.println(i);
	  i\*=2;	
	}

	else
	break;
}
System.out.println(i);
============================================================================================================================================================

I/O operations :

InputStreamReader i = new InuttStreamReader(System.in);
BuferedReader b = new BufferedReader(i);

String name = b.readLine();

=>  or we can use Scanner  class also .

Scanner s = new Scanner (System.in);



Example program:

import java.util.Scanner;

public class PrimitiveInputExample {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Taking input for each primitive type

        System.out.print("Enter a byte value: ");
        byte byteValue = scanner.nextByte();					

        System.out.print("Enter a short value: ");
        short shortValue = scanner.nextShort();

        System.out.print("Enter an int value: ");
        int intValue = scanner.nextInt();

        System.out.print("Enter a long value: ");
        long longValue = scanner.nextLong();

        System.out.print("Enter a float value: ");
        float floatValue = scanner.nextFloat();

        System.out.print("Enter a double value: ");
        double doubleValue = scanner.nextDouble();

        System.out.print("Enter a boolean value (true/false): ");
        boolean booleanValue = scanner.nextBoolean();

        System.out.print("Enter a character: ");
        char charValue = scanner.next().charAt(0); // Read string and take first character

        // Displaying the values
        System.out.println("\nYou entered:");
        System.out.println("Byte: " + byteValue);
        System.out.println("Short: " + shortValue);
        System.out.println("Int: " + intValue);
        System.out.println("Long: " + longValue);
        System.out.println("Float: " + floatValue);
        System.out.println("Double: " + doubleValue);
        System.out.println("Boolean: " + booleanValue);
        System.out.println("Char: " + charValue);

        scanner.close();
    }
}
============================================================================================================================================================
Arrays in java :
```````````````
OneDimensional array:

// Declaration
dataType[] arrayName;

// Declaration + Memory Allocation
dataType[] arrayName = new dataType[size];

// Declaration + Initialization
dataType[] arrayName = {value1, value2, value3, ..., valueN};


1) Indexing  		: 	Array indices start from 0. So, the first element is at index 0, second at 1, and so on.
2) Fixed Size 		:	Once declared, the size of an array cannot be changed.
3) Homogeneous Elements : 	All elements must be of the same data type.
4) Accessing Elements   : 	Use arrayName[index] to access or modify elements.
5) Length 		: 	Use arrayName.length to get the number of elements.

Common points to remember :
- Traversal: Loop through each element
- Search: Linear search or binary search (if sorted)
- Sort: Use Arrays.sort(array)
- Copy: Use Arrays.copyOf() or manual loop
- Reverse: Swap elements from both ends

Example Program :

public class ArrayExample {
    public static void main(String[] args) {
        int[] scores = new int[5];

        // Assign values
        scores[0] = 70;
        scores[1] = 85;
        scores[2] = 90;
        scores[3] = 75;
        scores[4] = 88;

        // Print values
        for (int i = 0; i < scores.length; i++) {
            System.out.println("Score " + (i+1) + ": " + scores[i]);
        }
    }
}

-------------------------------------------------------------------------------------------------------------------------------------------------------------------
2D Array:

A 2D array in Java is an array of arrays, allowing you to store data in a grid-like structure with rows and columns. It's ideal for representing matrices, tables, or board games.

üõ†Ô∏è Declaration and Initialization

// Declaration
int[][] arr;

// Initialization
arr = new int[3][4]; // 3 rows, 4 columns

// Declaration + Initialization
int[][] grid = {
    {10, 20},
    {30, 40},
    {50, 60}
};



üì¶ Accessing and Modifying Elements
System.out.println(grid[1][1]); // Output: 40

grid[2][0] = 55; // Update value at row 2, column 0



üîÅ Iterating Through a 2D Array

for (int i = 0; i < grid.length; i++) {
    for (int j = 0; j < grid[i].length; j++) {
        System.out.print(grid[i][j] + " ");
    }
    System.out.println();
}



‚úÖ Example Program

public class TwoDArrayExample {
    public static void main(String[] args) {
        int[][] marks = new int[2][3];

        // Assign values
        marks[0][0] = 85;
        marks[0][1] = 90;
        marks[0][2] = 78;
        marks[1][0] = 88;
        marks[1][1] = 92;
        marks[1][2] = 81;

        // Print values
        for (int i = 0; i < marks.length; i++) {
            for (int j = 0; j < marks[i].length; j++) {
                System.out.print(marks[i][j] + " ");
            }
            System.out.println();
        }
    }
}



üß© Key Concepts
Declaration  int[[]arr;
Initialization arr=new int[rows][cols];
Access arr[i][j];
Update arr[i][j] = value;
length   arr.length for rows ,arr[i].length for colums
Iteration   we use nested for loop.

üß† Use Cases
- Matrices and mathematical operations
- Game boards (like chess or tic-tac-toe)
- Tabular data (student marks, sales reports)
- Image processing (pixel grids)


===================================================================================================================================================================

String ,StringBuilder & String buffer: 

In Java, String, StringBuilder, and StringBuffer are classes used to handle text, but they differ in mutability, performance, and thread safety.

1. String ‚Äì Immutable Text
- Immutable: Once created, a String cannot be changed.
- Stored in String Pool: Helps with memory efficiency.
- Best for: Fixed or rarely modified text.
‚úÖ Example:
String str = "Hello";
str.concat(" World");
System.out.println(str); // Output: Hello

str.concat(" World") creates a new string but doesn't change str.

üß± 2. StringBuilder ‚Äì Mutable & Fast
- Mutable: Can change content without creating new objects.
- Not thread-safe: Faster in single-threaded environments.
- Best for: Frequent string modifications (e.g., loops, appends).
‚úÖ Example:
StringBuilder sb = new StringBuilder("Hello");
sb.append(" World");
System.out.println(sb); // Output: Hello World


üîß Common Methods:
- append()
- insert()
- delete()
- reverse()
- toString()


üßµ 3. StringBuffer ‚Äì Mutable & Thread-Safe
- Mutable: Like StringBuilder.
- Thread-safe: Synchronized methods.
- Best for: Multi-threaded applications needing safe string operations.
‚úÖ Example:
StringBuffer sbf = new StringBuffer("Hello");
sbf.append(" World");
System.out.println(sbf); // Output: Hello World



üß† When to Use What?
- Use String when the text doesn‚Äôt change.
- Use StringBuilder for fast, single-threaded edits.
- Use StringBuffer for thread-safe operations.


OOPS Features:

Class 
Object 
Abstraction
Encapsulation
Polymorphism
Inheritance

üß© 1. Abstraction
‚úÖ Definition:

Abstraction is the process of hiding implementation details and showing only the essential features of an object.
It helps to reduce complexity and increase reusability.

Achieved using abstract classes or interfaces.

üíª Example:
// Abstract class example
abstract class Vehicle {
    abstract void start(); // abstract method (no body)
}

class Car extends Vehicle {
    void start() {
        System.out.println("Car starts with a key");
    }
}

class Bike extends Vehicle {
    void start() {
        System.out.println("Bike starts with a kick");
    }
}

public class AbstractionExample {
    public static void main(String[] args) {
        Vehicle v1 = new Car();
        Vehicle v2 = new Bike();

        v1.start();
        v2.start();
    }
}

üß† Output:
Car starts with a key
Bike starts with a kick

=============================================================================================
üß≥ 2. Encapsulation
‚úÖ Definition:

Encapsulation means wrapping data (variables) and code (methods) together as a single unit.
It helps to protect data from unauthorized access by using private fields and public getters/setters.

üíª Example:
class Student {
    private String name; // private data
    private int age;

    // Public getter and setter methods
    public void setName(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }

    public void setAge(int age) {
        if (age > 0) {
            this.age = age;
        }
    }
    public int getAge() {
        return age;
    }
}

public class EncapsulationExample {
    public static void main(String[] args) {
        Student s = new Student();
        s.setName("John");
        s.setAge(20);

        System.out.println("Name: " + s.getName());
        System.out.println("Age: " + s.getAge());
    }
}

üß† Output:
Name: John
Age: 20

=============================================================================================
üé≠ 3. Polymorphism
‚úÖ Definition:

Polymorphism means ‚Äúmany forms‚Äù ‚Äî it allows one action to behave differently based on the object.

Achieved through:

Compile-time polymorphism ‚Üí Method Overloading

Runtime polymorphism ‚Üí Method Overriding

üíª (a) Compile-time Polymorphism - Method Overloading
class Calculator {
    int add(int a, int b) {
        return a + b;
    }

    int add(int a, int b, int c) {
        return a + b + c;
    }
}

public class OverloadingExample {
    public static void main(String[] args) {
        Calculator c = new Calculator();
        System.out.println(c.add(10, 20));       // calls 2-parameter method
        System.out.println(c.add(10, 20, 30));   // calls 3-parameter method
    }
}

üß† Output:
30
60

üíª (b) Runtime Polymorphism - Method Overriding
class Animal {
    void sound() {
        System.out.println("Animal makes sound");
    }
}

class Dog extends Animal {
    void sound() {
        System.out.println("Dog barks");
    }
}

public class OverridingExample {
    public static void main(String[] args) {
        Animal a = new Dog(); // upcasting
        a.sound(); // runtime polymorphism
    }
}

üß† Output:
Dog barks
=============================================================================================

üß¨ 4. Inheritance
‚úÖ Definition:

Inheritance allows a class (child/subclass) to inherit properties and methods from another class (parent/superclass).
It promotes code reusability and hierarchical classification.

üíª Example:
class Person {
    String name = "John";

    void showName() {
        System.out.println("Name: " + name);
    }
}

class Employee extends Person {
    String company = "Google";

    void showCompany() {
        System.out.println("Company: " + company);
    }
}

public class InheritanceExample {
    public static void main(String[] args) {
        Employee e = new Employee();
        e.showName();      // inherited method
        e.showCompany();   // own method
    }
}

üß† Output:
Name: John
Company: Google


=====================================================================================================================================================================
METHODS IN JAVA:
```````````````
A Method represents group of statements that performs a task.

Based on Static Keyword :
````````````````````````
Static methods
Instance methods

Based on parameters:
````````````````````
Parameterised methods
non-Parameterises methods

Based on return type:
````````````````````
With return type
Without return type


Difference between function and method ?
	Functions that are defined inside a class are said to be methods.
How to create a method ?
A method can be declared as follows:

static/non static returntype methodname (optional parameters)
{
	// method code
}


We can invoke/call the method of a class by using object.

objectname.method(optional parameters)

Here the parameters must be matched with the method definition in number of parameters and their data types.
following example defines printarray method in class ArEx and it is invoked from main class by creating object .

Example program to demonstrate addition of two numbers using methods concept:
class MethodAt
    {
         public static void main(String ar[])
         {
             Sum ob = new Sum();	//obj creation
             ob.add(2,3);	//method call
         }
    }
class Sum
    {
        void add(int a,int b){
            int addition = a+b;
            System.out.println("Sum of "+a+" & "+b+" is "+addition);
        } 
    }
========================================================================================================================================================================
CONSTRUCTORS IN JAVA:
````````````````````
Constructors in Java are special methods used to initialize objects when they are created. They have the same name as the class and no return type.

üß± What is a Constructor?
A constructor is a block of code that:
- Has the same name as the class
- Does not have a return type (not even void)
- Is automatically called when an object is created using new
- Is used to initialize object properties

üìå Key Rules of Constructors
- Must have the same name as the class.
- Cannot be abstract, static, final, or synchronized.
- Can be overloaded (multiple constructors with different parameters).
- Can call another constructor using this() or super().


‚úÖ Example 1: Default Constructor:

class Car {
    Car() {
        System.out.println("Default constructor called");
    }

    public static void main(String[] args) {
        Car myCar = new Car(); // Constructor is called here
    }
}

Output:
Default constructor called

‚úÖ Example 2: Parameterized Constructor
class Car {
    String model;

    Car(String m) {
        model = m;
    }

    public static void main(String[] args) {
        Car myCar = new Car("Honda City");
        System.out.println("Model: " + myCar.model);
    }
}
Output:
Model: Honda City


‚úÖ Example 3: Constructor Overloading


class Car {
    String model;
    int year;

    Car() {
        model = "Unknown";
        year = 0;
    }

    Car(String m, int y) {
        model = m;
        year = y;
    }

    public void display() {
        System.out.println("Model: " + model + ", Year: " + year);
    }

    public static void main(String[] args) {
        Car car1 = new Car();
        Car car2 = new Car("Hyundai i20", 2022);
        car1.display();
        car2.display();
    }
}
Output:
Model: Unknown, Year: 0
Model: Hyundai i20, Year: 2022

üîÅ Example 4: Copy Constructor

class Car {
    String model;

    Car(String m) {
        model = m;
    }

    // Copy constructor
    Car(Car c) {
        model = c.model;
    }

    public void display() {
        System.out.println("Model: " + model);
    }

    public static void main(String[] args) {
        Car car1 = new Car("Tata Nexon");
        Car car2 = new Car(car1); // Copy constructor
        car2.display();
    }
}
Output :

Model: Tata Nexon

